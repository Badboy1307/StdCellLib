#!/usr/bin/env tclsh
#   ************    LibreSilicon's StdCellLibrary   *******************
#
#   Organisation:   Chipforge
#                   Germany / European Union
#
#   Profile:        Chipforge focus on fine System-on-Chip Cores in
#                   Verilog HDL Code which are easy understandable and
#                   adjustable. For further information see
#                           www.chipforge.org
#                   there are projects from small cores up to PCBs, too.
#
#   File:           popcorn
#
#   Purpose:        Generates a bunch of combinatorial cells
#
#   ************    Tcl 8.6 Shell Script    ***************************
#
#   ///////////////////////////////////////////////////////////////////
#
#       Copyright (c)   2018 by
#                       SANKOWSKI, Hagen - hsank@nospam.chipforge.org
#
#   This source file may be used and distributed without restriction
#   provided that this copyright statement is not removed from the
#   file and that any derivative work contains the original copyright
#   notice and the associated disclaimer.
#
#   This source is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 3 of the License, or
#   (at your option) any later version.
#
#   This source is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#    (__)  You should have received a copy of the GNU General Public
#    oo )  License along with this program; if not, write to the
#    /_/|  Free Software Foundation Inc., 51 Franklin St., 5th Floor,
#          Boston, MA 02110-1301, USA
#
#   GNU General Public License v3.0 - http://www.gnu.org/licenses/gpl-3.0.html
#   ///////////////////////////////////////////////////////////////////

#   -------------------------------------------------------------------
#                       DESCRIPTION
#   -------------------------------------------------------------------

#   This tool generates transistor networks for Standard Cells.
#   Usually - for CMOS - this transistor networks are
#       * one pull-up network, build with pmos transistors, and
#       * one pull-down network, build with nmos transistors.

#   --------*---------  vdd
#        ___|___
#       |       |
#       | pull- |
#       |  up   |
#       |_______|
#           |
#           *-------->  Z
#        ___|___
#       |       |
#       | pull- |
#       | down  |
#       |_______|
#           |
#   --------*---------  gnd

#   -------------------------------------------------------------------
#                       DEFINITIONS
#   -------------------------------------------------------------------

#   seed library with know cells

#   array index is cellid, the content structure is a list with
#   { { pull-up network } { pull-down network } }, where every pullup/pulldown network
#   is a list of transistors itself {{ gate drain source mosfet }..}
set library(INV)        {{{A Z vdd pmos}} {{A Z gnd nmos}}}
set library(NOR2)       {{{B 1 vdd pmos} {A Z 1 pmos}} {{B Z gnd nmos} {A Z gnd nmos}}}
set library(NAND2)      {{{B Z vdd pmos} {A Z vdd pmos}} {{B 2 gnd nmos} {A Z 2 nmos}}}

# usable inputs
set table {A B C D E F G H J K L M N P T U V W}

#   ------------    proc 'export!'  -----------------------------------

#   write into fresh cell file

#   use $library list structure
proc export! {path cellid netlist} {

    global verbose

    # open cell output file
    set datafile [file join $path $cellid\.cell]
    set f [open $datafile w]

    # verbose message
    if {$verbose} {
        puts "export: $datafile"
    }

    # write out
    puts $f ".AUTOGENERATED by Popcorn Tcl Script"
    puts $f ".ORDER \"Gate Drain Source MOSFET\""
    foreach network $netlist {
        foreach mosfet $network {
            puts $f $mosfet
        }
    }

    # done
    close $f
}

#   -------------------------------------------------------------------
#                       FUNCTIONS
#   -------------------------------------------------------------------

#   ------------    proc 'nodes?'   -----------------------------------

#   list all nodes involved in any network in a decreasing order

proc nodes? {network} {

    global verbose

    # work out
    set unsorted {}
    foreach mosfet $network {
        lappend unsorted [lindex $mosfet 1] ; # drain is 2nd element in list
        lappend unsorted [lindex $mosfet 2] ; # source is 3rd element in list
    }

    # sort list decreasing and unique
    set nodes [lsort -decreasing -unique -dictionary $unsorted]

    # verbose message
    if {$verbose} {
        puts "nodes?: $unsorted > $nodes"
    }

    # done
    return $nodes
}

#   ------------    proc 'pullup_nodes?'    ---------------------------

#   list all nodes involved in pullup network in a decreasing order

proc pullup_nodes? {netlist} {

    # wrapper
    return [nodes? [lindex $netlist 0]] ; # pullup network is the 1st element in list
}

#   ------------    proc 'pulldown_nodes?'  ---------------------------

#   list all nodes involved in pulldown network in a decreasing order

proc pulldown_nodes? {netlist} {

    # wrapper
    return [nodes? [lindex $netlist 1]] ; # pulldown network is the 2nd element in list
}

#   ------------    proc 'maxnode?' -----------------------------------

#   get highest node in network (w/ maximum number)

proc maxnode? {network} {

    global verbose

    # work out
    set nodes [nodes? $network] 
    set maxnode -1
    foreach item $nodes {
        if {[string is entier $item]} {
            set maxnode $item
            break
        }
    }

    # verbose message
    if {$verbose} {
        puts "maxnode?: $maxnode"
    }

    # done
    return $maxnode
}

#   ------------    proc 'pullup_maxnode?'  ---------------------------

#   get highest node in pullup network (w/ maximum number)

proc pullup_maxnode? {netlist} {

    # wrapper
    return [maxnode? [lindex $netlist 0]] ; # pulldown network is the 1st element in list
}

#   ------------    proc 'pulldown_maxnode?'    -----------------------

#   get highest node in pulldown network (w/ maximum number)

proc pulldown_maxnode? {netlist} {

    # wrapper
    set maxnode [maxnode? [lindex $netlist 1]] ; # pullup network is the 2nd element in list
    if {$maxnode eq -1} {
        return 0
    } else {
        return $maxnode
    }
}

#   ------------    proc 'inputs?'  -----------------------------------

#   list all inputs involved in any network in a decreasing order

proc inputs? {network} {

    global verbose

    # collect all inputs form pullup network
    set unsorted {}
    foreach mosfet $network {
        lappend unsorted [lindex [lindex $mosfet 0] 0] ; # gate is 1st element in list
    }
    # sort inputs
    set inputs [lsort -decreasing -unique -dictionary $unsorted]

    # verbose message
    if {$verbose} {
        puts "inputs?: $inputs"
    }

    # done
    return $inputs
}

#   ------------    proc 'pullup_inputs?'   ---------------------------

#   list all inputs involved in pullup network in a decreasing order

proc pullup_inputs? {netlist} {

    # wrapper
    return [inputs? [lindex $netlist 0]] ; # pullup network is the 1st element in list
}

#   ------------    proc 'pulldown_inputs?'     -----------------------

#   list all inputs involved in pulldown network in a decreasing order

proc pulldown_inputs? {netlist} {

    # wrapper
    return [inputs? [lindex $netlist 1]] ; # pulldown network is the 2nd element in list
}

#   ------------    proc 'column?'  -----------------------------------

#   find first column in any network which is shorter than 'stacked' option
#   needs current path in column, returns full path

proc column? {column from to network} {

    global verbose
    global option_stacked

    # work out
    if {[llength $column] < $option_stacked} {
        foreach mosfet $network {
            # check network for $from on mosfet as drain
            if {[lindex $mosfet 1] eq $from} {

                # check all transistor sources as next nodes
                if {[lindex $mosfet 2] eq $to} {
                    # found last transistor in chain
                    set column [lappend column $mosfet]
                } else {
                    # current node is intermediate, go deeper
                    set column [column? [lappend column $mosfet] [lindex $mosfet 2] $to $network]
                }
            }
        }
    } else {
        set column {}
    }

    # verbose message
    if {$verbose} {
        puts "column?: [llength $column] $option_stacked [lsort -decreasing $column]"
    }

    # done
    return [lsort -decreasing $column]
}

#   ------------    proc 'column_pullup?'   ---------------------------

#   find first column in pullup network which is shorter than 'stacked' option

proc column_pullup? {netlist} {

    # wraper
    return [column? {} "Z" "vdd" [lindex $netlist 0]] ; # pullup network is the 1st element in list
}

#   ------------    proc 'column_pulldown?'     -----------------------

#   find first column in pullup network which is shorter than 'stacked' option

proc column_pulldown? {netlist} {

    # wraper
    return [column? {} "Z" "gnd" [lindex $netlist 1]] ; # pulldown network is the 2nd element in list
}

#   ------------    proc 'input_number!'    ---------------------------

#   generate input (gate) name from $input following the numbers

proc input_number! {input} {

    global verbose

    # work out
    set number 1
    set char [string range $input 0 0]
    if {[string length $input] > 1} {
        # input (gate) name already has a number
        set number [expr [string range $input 1 end] +1]
    }
    # combine char and number
    set input [string cat $char $number]

    # verbose message
    if {$verbose} {
        puts "input_number!: $input"
    }

    # done
    return $input
}

#   ------------    proc 'input_char!'  -------------------------------

#   generate input (gate) name from $input following the alphabet

proc input_char! {input} {

    global verbose
    global table

    # work out
    set new_input [lindex $table [expr [lsearch -exact $table $input] +1]]

    # verbose message
    if {$verbose} {
        puts "input_char!: $input > $new_input"
    }

    # done
    return $new_input
}

#   ------------    proc 'enlarge_nand!'    ---------------------------

#   find not fully filled column in pulldown network and enlarge both networks

proc enlarge_nand! {nameing netlist} {

    global verbose

    # start with pulldown network
    set network [lindex $netlist 1] ; # pulldown network is the 2nd element in list
    set column [column_pulldown? $netlist] ; # find free column

    if {$column eq {}} {
        set netlist $column
    } else {
        # identify mosfet to replace with higher node number
        set orgfet [lindex $column 0] ; # mosfet on most-left position on column

        set index [lsearch $network $orgfet] ; # network position where to replace

        # prepare replacement
        set node [expr [pulldown_maxnode? $netlist] +2] ; # get highest node number, add 2, for connectivity
        set patch [lreplace $orgfet 2 2 $node] ; # path original mosfet with new node number
        set gate [lindex $orgfet 0] ; # get current input / gate name
        # generate next input / gate name regarding 'proc -naming'
        if {$nameing eq "number"} {
            set newgate [input_number! $gate]
        } else {
            set newgate [input_char! $gate]
        }
        set newfet [list $newgate $node gnd nmos]; # combine new mosfet to add

        # extend pulldown column
        set pulldown [concat [list $newfet] [lreplace $network $index $index $patch]] ; # patch original mosfet and add new one

        # follow up with pullup network
        set network [lindex $netlist 0] ; # pulldown network is the 1st element in list

        # identify mosfet to "double"
        foreach mosfet $network {
            if {[lindex $mosfet 0] eq $gate} {
                set orgfet $mosfet
            }
        }

        # prepare addition
        set newfet [lreplace $orgfet 0 0 $newgate]

        # extend pullup row
        set pullup [concat [list $newfet] $network]

        set netlist [list [lsort -decreasing $pullup] [lsort -decreasing $pulldown]]
    }
    # verbose message
    if {$verbose} {
        puts "enlarge_nand!: $netlist"
    }

    # done
    return $netlist
}

#   ------------    proc 'enlarge_nor!'     ---------------------------

#   find not fully developed column in pullup network and enlarge both networks

proc enlarge_nor! {nameing netlist} {

    global verbose

    # start with pullup network
    set network [lindex $netlist 0] ; # pullup network is the 1st element in list
    set column [column_pullup? $netlist] ; # find free column

    if {$column eq {}} {
        set netlist $column
    } else {
        # identify mosfet to replace with higher node number
        set orgfet [lindex $column 0] ; # mosfet on most-left position on column

        set index [lsearch $network $orgfet] ; # network position where to replace

        # prepare replacement
        set node [expr [pullup_maxnode? $netlist] +2] ; # get highest node number, add 2, for connectivity
        set patch [lreplace $orgfet 2 2 $node] ; # path original mosfet with new node number
        set gate [lindex $orgfet 0] ; # get current input / gate name
        # generate next input / gate name regarding 'proc -naming'
        if {$nameing eq "number"} {
            set newgate [input_number! $gate]
        } else {
            set newgate [input_char! $gate]
        }
        set newfet [list $newgate $node vdd pmos]; # combine new mosfet to add

        # extend pulldown column
        set pullup [concat [list $newfet] [lreplace $network $index $index $patch]] ; # patch original mosfet and add new one

        # follow up with pulldown network
        set network [lindex $netlist 1] ; # pullup network is the 1st element in list

        # identify mosfet to "double"
        foreach mosfet $network {
            if {[lindex $mosfet 0] eq $gate} {
                set orgfet $mosfet
                break
            }
        }

        # prepare addition
        set newfet [lreplace $orgfet 0 0 $newgate]

        # extend pullup row
        set pulldown [concat [list $newfet] $network]

        set netlist [list [lsort -decreasing $pullup] [lsort -decreasing $pulldown]]
    }
    # verbose message
    if {$verbose} {
        puts "enlarge_nor!: $netlist"
    }

    # done
    return $netlist
}

#   ------------    proc 'cellnames!'   -------------------------------

#   evaluate namespace for cells

proc cellnames! {nameing cellid netlist} {

    global verbose
    global table

    # cut out and store group header
    switch -glob -- $cellid {
        NAND*   {set index 3}
        NOR*    {set index 2}
        AOI*    {set index 2}
        XOR*    {set index 2}
        OAI*    {set index 2}
        AO*     {set index 1}
        EQ*     {set index 1}
        OA*     {set index 1}
        default break
    }
    set header [string range $cellid 0 $index]

    # evaluate numbering

    set number ""
    if {$nameing eq "number"} {

        # initialize scoreboard
        foreach char $table {
            set scoreboard($char) 0
        }
        # count up input occurances
        foreach item [pullup_inputs? $netlist] {
            incr scoreboard([string range $item 0 0])
        }
        # concatinate
        foreach item $table {
            if {$scoreboard($item) > 0} {
                set number [string cat $scoreboard($item) $number]
            }
        }
    } else {
        set number [llength [pullup_inputs? $netlist]]
    }

    # combine char and number
    set cellid [string cat $header $number]

    # verbose message
    if {$verbose} {
        puts "cellname!: $cellid"
    }

    # done
    return $cellid
}

#   ------------    proc 'nor_group!'   -------------------------------

#   generate recursive NOR gates

proc nor_group! {cellid netlist} {

    global verbose
    global stepmode
    global library

    #   work out
    set nor [enlarge_nor! char $netlist]
    if {$nor ne {}} {
        set norid [cellnames! char $cellid $nor]
        puts "nor_group/nor"
        puts "$cellid $netlist ->"
        puts "$norid $nor"
        set library($norid) $nor
        if {$stepmode} {
            set enter [gets stdin]
        }
        nor_group! $norid $nor
    }
}

#   ------------    proc 'aoi_group!'   -------------------------------

#   generate recursive AOI complex gates

proc aoi_group! {cellid netlist} {

    global verbose
    global stepmode
    global library

    #   work out
    set nand [enlarge_nand! number $netlist]
    if {$nand ne {}} {
        set nandid [cellnames! number $cellid $nand]
        puts "aoi_group/nand"
        puts "$cellid $netlist ->"
        puts "$nandid $nand"
        set library($nandid) $nand
        if {$stepmode} {
            set enter [gets stdin]
        }
        aoi_group! $nandid $nand
    }
}

#   ------------    proc 'nand_group!'  -------------------------------

#   generate recursive NAND gates

proc nand_group! {cellid netlist} {

    global verbose
    global stepmode
    global library

    #   work out
    set nand [enlarge_nand! char $netlist]
    if {$nand ne {}} {
        set nandid [cellnames! char $cellid $nand]
        puts "nand_group/nand"
        puts "$cellid $netlist ->"
        puts "$nandid $nand"
        set library($nandid) $nand
        if {$stepmode} {
            set enter [gets stdin]
        }
        nand_group! $nandid $nand
    }
}
#   ------------    proc 'oai_group!'   -------------------------------

#   generate recursive OAI complex gates

proc oai_group! {cellid netlist} {

    global verbose
    global stepmode
    global library

    #   work out
    set nor [enlarge_nor! number $netlist]
    if {$nor ne {}} {
        set norid [cellnames! number "OAI" $nor]
        puts "oai_group/nor"
        puts "$cellid $netlist ->"
        puts "$norid $nor"
        set library($norid) $nor
        if {$stepmode} {
            set enter [gets stdin]
        }
        oai_group! $norid $nor
    }
}

#   -------------------------------------------------------------------
#                       MAIN
#   -------------------------------------------------------------------

#   ------------    Command line parsing     --------------------------

package require cmdline;

#   define program options
set options {
    {o.arg "./"         "specify output directory - default" }
    {t.arg "4"          "reduce number of stacked transistors - default" }
    {s                  "single step mode" }
    {v                  "verbose" }
}

#   define program usage
set usage "- Generate a bunch of combinatorial cells"

#   error trap
try {
    array set params [cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
    # Trap the usage signal, print the massage, and exit the application.
    # Note: Others errors are not caught and passed through to higher levels!
    puts $msg
    exit -1 
}

#   set argv from command lines
set option_stacked [expr $params(t) -1] ; # number of stacked transistors
set option_path $params(o) ; # output directory
set stepmode $params(s); 
set verbose $params(v); 

#   verbose message
if {$verbose} {
    puts "[clock format [clock seconds] -gmt 1]"
    puts "option_stacked (-s): [expr $option_stacked +1]"
    puts "option_path (-o): $option_path"
}

#   ------------    cell generation     -------------------------------

#   set first seed
set seed $library(INV)

set nandgroup [enlarge_nand! char $seed]
set library(NAND2) $nandgroup

set norgroup [enlarge_nor! char $seed]
set library(NOR2) $norgroup

nor_group! "NOR2" $library(NOR2)
nand_group! "NAND2" $library(NAND2)

set aoigroup [enlarge_nand! number $library(NOR2)]
set library(AOI21) $aoigroup
aoi_group! "AOI21" $library(AOI21)

set oaigroup [enlarge_nor! number $library(NAND2)]
set library(OAI21) $aoigroup
oai_group! "OAI21" $library(OAI21)

#   export results
foreach cellid [array names library] {
    export! $option_path $cellid $library($cellid)
}

#   thanks for all the fish!
