#!/usr/bin/env tclsh
#   ************    LibreSilicon's StdCellLibrary   *******************
#
#   Organisation:   Chipforge
#                   Germany / European Union
#
#   Profile:        Chipforge focus on fine System-on-Chip Cores in
#                   Verilog HDL Code which are easy understandable and
#                   adjustable. For further information see
#                           www.chipforge.org
#                   there are projects from small cores up to PCBs, too.
#
#   File:           popcorn
#
#   Purpose:        Generates a bunch of combinatorial cells
#
#   ************    Tcl 8.6 Shell Script    ***************************
#
#   ///////////////////////////////////////////////////////////////////
#
#       Copyright (c)   2018 by
#                       SANKOWSKI, Hagen - hsank@nospam.chipforge.org
#
#   This source file may be used and distributed without restriction
#   provided that this copyright statement is not removed from the
#   file and that any derivative work contains the original copyright
#   notice and the associated disclaimer.
#
#   This source is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 3 of the License, or
#   (at your option) any later version.
#
#   This source is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#    (__)  You should have received a copy of the GNU General Public
#    oo )  License along with this program; if not, write to the
#    /_/|  Free Software Foundation Inc., 51 Franklin St., 5th Floor,
#          Boston, MA 02110-1301, USA
#
#   GNU General Public License v3.0 - http://www.gnu.org/licenses/gpl-3.0.html
#   ///////////////////////////////////////////////////////////////////

#   -------------------------------------------------------------------
#                       DESCRIPTION
#   -------------------------------------------------------------------

#   This tool generates transistor networks for Standard Cells.
#   Usually - for CMOS - this transistor networks are
#       * one pull-up network, build with pmos transistors, and
#       * one pull-down network, build with nmos transistors.

#   --------*---------  vdd
#        ___|___
#       |       |
#       | pull- |
#       |  up   |
#       |_______|
#           |
#           *-------->  Z
#        ___|___
#       |       |
#       | pull- |
#       | down  |
#       |_______|
#           |
#   --------*---------  gnd

#   -------------------------------------------------------------------
#                       DEFINITIONS
#   -------------------------------------------------------------------

#   seed library with know cells

#   array index is cellid, the content structure is a list with
#   { { pull-up network } { pull-down network } }, where every pullup/pulldown network
#   is a list of transistors itself {{ gate drain source mosfet }..}
set library(INV)        { {{A Z vdd pmos}} \
                          {{A Z gnd nmos}} }
set library(NOR2)       { {{B 1 vdd pmos} \
                           {A Z 1 pmos}} \
                          {{A Z gnd nmos} {B Z gnd nmos}} }
set library(NAND2)      { {{A Z vdd pmos} {B Z vdd pmos}} \
                          {{A Z 2 nmos} \
                           {B 2 gnd nmos}} }

#   ------------    proc 'export!'  -----------------------------------

#   write into fresh cell file

#   use $library list structure
proc export! {path cellid netlist} {

    global verbose

    # open cell output file
    set datafile [file join $path $cellid\.cell]
    set f [open $datafile w]

    # verbose message
    if {$verbose} {
        puts "export: $datafile"
    }

    # write out
    puts $f ".AUTOGENERATED by Popcorn Tcl Script"
    puts $f ".ORDER \"Gate Drain Source MOSFET\""
    foreach network $netlist {
        foreach mosfet $network {
            puts $f $mosfet
        }
    }

    # done
    close $f
}

#   -------------------------------------------------------------------
#                       FUNCTIONS
#   -------------------------------------------------------------------

#   ------------    proc 'pullup_nodes?'    ---------------------------

#   list all nodes involved in pullup network in a decreasing order

proc pullup_nodes? {netlist} {

    global verbose

    # work out
    set unsorted {}
    set network [lindex $netlist 0] ; # pullup network is the 1st element in list
    foreach mosfet $network {
        lappend unsorted [lindex $mosfet 1] ; # drain is 2nd element in list
        lappend unsorted [lindex $mosfet 2] ; # source is 3rd element in list
    }

    # sort list decreasing and unique
    set nodes [lsort -decreasing -unique -dictionary $unsorted]

    # verbose message
    if {$verbose} {
        puts "pullup_nodes?: $unsorted > $nodes"
    }

    # done
    return $nodes
}

#   ------------    proc 'pulldown_nodes?'  ---------------------------

#   list all nodes involved in pulldown network in a decreasing order

proc pulldown_nodes? {netlist} {

    global verbose

    # work out
    set unsorted {}
    set network [lindex $netlist 1] ; # pulldown network is the 2nd element in list
    foreach mosfet $network {
        lappend unsorted [lindex $mosfet 1] ; # drain is 2nd element in list
        lappend unsorted [lindex $mosfet 2] ; # source is 3rd element in list
    }

    # sort list decreasing and unique
    set nodes [lsort -decreasing -unique -dictionary $unsorted]

    # verbose message
    if {$verbose} {
        puts "pulldown_nodes?: $unsorted > $nodes"
    }

    # done
    return $nodes
}

#   ------------    proc 'input_nodes?'     ---------------------------

#   list all inputs involved in pullup/pulldown networks and compare them

proc input_nodes? {netlist} {

    global verbose

    # collect all inputs form pullup network
    set unsorted_up {}
    set network [lindex $netlist 0] ; # pullup network is the 1st element in list
    foreach mosfet $network {
        lappend unsorted_up [lindex [lindex $mosfet 0] 0] ; # gate is 1st element in list
    }
    # sort pullup
    set pullup [lsort -decreasing -unique -dictionary $unsorted_up]

    # collect all inputs form pulldown network
    set unsorted_down {}
    set network [lindex $netlist 1] ; # pulldown network is the 2nd element in list
    foreach mosfet $network {
        lappend unsorted_down [lindex [lindex $mosfet 0] 0]; # gate is 1st element in list
    }
    # sort pulldown
    set pulldown [lsort -decreasing -unique -dictionary $unsorted_down]

    # ?? compare both lists here!
    set nodes $pulldown ; # !!

    # verbose message
    if {$verbose} {
        puts "input_nodes?: $pullup $pulldown"
    }

    # done
    return $nodes
}

#   ------------    proc 'highest_pullup?'  ---------------------------

#   get highest pullup node

proc highest_pullup? {nodes} {

    global verbose

    # work out
    set node -1 
    foreach item $nodes {
        if {[string is entier $item]} {
            set node $item
            break
        }
    }

    # verbose message
    if {$verbose} {
        puts "highest_pullup?: $node"
    }

    # done
    return $node
}

#   ------------    proc 'highest_pulldown?'    -----------------------

#   get highest pulldown node

proc highest_pulldown? {nodes} {

    global verbose

    # work out
    set node 0
    foreach item $nodes {
        if {[string is entier $item]} {
            set node $item
            break
        }
    }

    # verbose message
    if {$verbose} {
        puts "highest_pulldown?: $node"
    }

    # done
    return $node
}

#   ------------    proc 'column_pullup?'   ---------------------------

#   find first column in pullup network which is shorter than 'stacked' option

proc column_pullup? {node depth netlist} {

    global verbose
    global option_stacked

    # work out
    set column {}
    if {$depth > $option_stacked} {
        # maximum depth reached, abort
        set column {}
    } else {
        # still space to evaluate
        set network [lindex $netlist 0] ; # pullup network is the 1st element in list
        # check network for $node on transistor as drain
        foreach mosfet $network {
            # check all transistors which start with $node
            if {[lindex $mosfet 1] eq $node} {

                # check all transistor sources as next nodes
                set next_node [lindex $mosfet 2]
                if {$next_node eq "vdd"} {
                    # found last transistor in chain
                    set column [list $mosfet]
                    break
                } else {
                    # current node is intermediate, go deeper
                    set column [column_pullup? $next_node [incr $depth] $netlist]
                }
                if {$column ne {}} {
                    set column [lappend column $mosfet]
                }
            }
        }
    }

    # verbose message
    if {$verbose} {
        puts "column_pullup?: $column"
    }

    # done
    return $column
}

#   ------------    proc 'column_pulldown?'     -----------------------

#   find first column in pulldown network which is shorter than 'stacked' option

proc column_pulldown? {node depth netlist} {

    global verbose
    global option_stacked

    # work out
    set column {}
    if {$depth > $option_stacked} {
        # maximum depth reached, abort
        set column {}
    } else {
        # still space to evaluate
        set network [lindex $netlist 1] ; # pulldown network is the 1st element in list
        # check network for $node on transistor as drain
        foreach mosfet $network {
            # check all transistors which start with $node
            if {[lindex $mosfet 1] eq $node} {

                # check all transistor sources as next nodes
                set next_node [lindex $mosfet 2]
                if {$next_node eq "gnd"} {
                    # found last transistor in chain
                    set column [list $mosfet]
                    break
                } else {
                    # current node is intermediate, go deeper
                    set column [column_pulldown? $next_node [incr $depth] $netlist]
                }
                if {$column ne {}} {
                    set column [lappend column $mosfet]
                }
            }
        }
    }

    # verbose message
    if {$verbose} {
        puts "column_pulldown?: $column"
    }

    # done
    return $column
}

#   -------------------------------------------------------------------
#                       MAIN
#   -------------------------------------------------------------------

#   ------------    Command line parsing     --------------------------

package require cmdline;

#   define program options
set options {
    {s.arg "4"          "reduce number of stacked transistors - default" }
    {o.arg "./"         "specify output directory - default" }
    {v                  "verbose" }
}

#   define program usage
set usage "- Generate a bunch of combinatorial cells"

#   error trap
try {
    array set params [cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
    # Trap the usage signal, print the massage, and exit the application.
    # Note: Others errors are not caught and passed through to higher levels!
    puts $msg
    exit -1 
}

#   set argv from command lines
set option_stacked $params(s) ; # number of stacked transistors
set option_path $params(o) ; # output directory
set verbose $params(v); 

#   verbose message
if {$verbose} {
    puts "[clock format [clock seconds] -gmt 1]"
    puts "option_stacked (-s): $option_stacked"
    puts "option_path (-o): $option_path"
}


#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   SANDBOX


# 
#foreach cellid [array names library *] {
#    puts [highest_pullup? [pullup_nodes? $library($cellid)]]
#    puts [highest_pulldown? [pulldown_nodes? $library($cellid)]]
#    puts [input_nodes? $library($cellid)]
#}

puts [column_pullup? Z 1 $library(INV)]
puts [column_pullup? Z 1 $library(NOR2)]
puts [column_pullup? Z 1 $library(NAND2)]
puts [column_pulldown? Z 1 $library(INV)]
puts [column_pulldown? Z 1 $library(NOR2)]
puts [column_pulldown? Z 1 $library(NAND2)]
