#!/usr/bin/env tclsh
#   ************    LibreSilicon's StdCellLibrary   *******************
#
#   Organisation:   Chipforge
#                   Germany / European Union
#
#   Profile:        Chipforge focus on fine System-on-Chip Cores in
#                   Verilog HDL Code which are easy understandable and
#                   adjustable. For further information see
#                           www.chipforge.org
#                   there are projects from small cores up to PCBs, too.
#
#   File:           popcorn
#
#   Purpose:        Generates a bunch of combinatorial cells
#
#   ************    Tcl 8.6 Shell Script    ***************************
#
#   ///////////////////////////////////////////////////////////////////
#
#       Copyright (c)   2018 by
#                       SANKOWSKI, Hagen - hsank@nospam.chipforge.org
#
#   This source file may be used and distributed without restriction
#   provided that this copyright statement is not removed from the
#   file and that any derivative work contains the original copyright
#   notice and the associated disclaimer.
#
#   This source is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 3 of the License, or
#   (at your option) any later version.
#
#   This source is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#   GNU General Public License for more details.
#
#    (__)  You should have received a copy of the GNU General Public
#    oo )  License along with this program; if not, write to the
#    /_/|  Free Software Foundation Inc., 51 Franklin St., 5th Floor,
#          Boston, MA 02110-1301, USA
#
#   GNU General Public License v3.0 - http://www.gnu.org/licenses/gpl-3.0.html
#   ///////////////////////////////////////////////////////////////////

#   -------------------------------------------------------------------
#                       DESCRIPTION
#   -------------------------------------------------------------------

#   This tool generates transistor networks for Standard Cells.
#   Usually - for CMOS - this transistor networks are
#       * one pull-up network, build with pmos transistors, and
#       * one pull-down network, build with nmos transistors.

#   --------*---------  vdd
#        ___|___
#       |       |
#       | pull- |
#       |  up   |
#       |_______|
#           |
#           *-------->  Z
#        ___|___
#       |       |
#       | pull- |
#       | down  |
#       |_______|
#           |
#   --------*---------  gnd

#   -------------------------------------------------------------------
#                       DEFINITIONS
#   -------------------------------------------------------------------

# seed library with know cells {cell {{ pull-up network } { pull-down network }}}
set library {
    {INV     {{pmos {A Z vdd}} \
              {nmos {A Z gnd}}}}
    {NOR2    {{pmos {B 1 vdd}} \
              {pmos {A Z 1}} \
              {nmos {A Z gnd}} {nmos {B Z gnd}}}}
    {NAND2   {{pmos {A Z vdd}} {pmos {B Z vdd}} \
              {nmos {A Z 2}} \
              {nmos {B 2 gnd}}}}
}

#   -------------------------------------------------------------------
#                       FUNCTIONS
#   -------------------------------------------------------------------

#   ------------    proc 'export'   -----------------------------------

# write into fresh cell file
proc export {path cell netlist} {

    global verbose

    # open cell output file
    set datafile [file join $path $cell\.func]
    set f [open $datafile w]

    # verbose message
    if {$verbose} {
        puts "export: $datafile"
    }

    # write out
    puts $f "# type {gate drain source}"
    foreach mosfet $netlist {
        puts $f $mosfet
    }

    # done
    close $f
}

#   ------------    proc 'list_inputs'  -------------------------------

# list all inputs in netlist
proc list_inputs {netlist} {

    global verbose

    # work out
    set inputs {}
    foreach mosfet $netlist {
        lappend inputs [lindex [lindex $mosfet 1] 0]
    }

    # verbose message
    if {$verbose} {
        puts "list_inputs: $inputs"
    }

    # done
    return [lsort -decreasing -unique $inputs]
}

#   ------------    proc 'list_nodes'   -------------------------------

# list all nodes in netlist, sorted, grouped for pullup and pulldown
proc list_nodes {netlist} {

    global verbose

    # work out
    set pullup {}
    set pulldown {}
    foreach mosfet $netlist {
        if {[lindex $mosfet 0] == {pmos}} {
            lappend pullup [lindex [lindex $mosfet 1] 1]
            lappend pullup [lindex [lindex $mosfet 1] 2]
        } elseif {[lindex $mosfet 0] == {nmos}} {
            lappend pulldown [lindex [lindex $mosfet 1] 1]
            lappend pulldown [lindex [lindex $mosfet 1] 2]
        }
    }

    # combine pull-up and pull-down networks
    set nodes [list [lsort -decreasing -unique -dictionary $pullup] [lsort -decreasing -unique -dictionary $pulldown]]

    # verbose message
    if {$verbose} {
        puts "list_nodes: $pullup $pulldown"
    }

    # done
    return $nodes
}

#   ------------    proc 'pullup_node'  -------------------------------

# get highest pullup node
proc pullup_node {nodes} {

    global verbose

    set node -1 
    foreach item [lindex $nodes 0] {
        if {[string is entier $item]} {
            set node $item
            break
        }
    }

    # verbose message
    if {$verbose} {
        puts "pullup_node: $node"
    }

    # done
    return $node
}

#   ------------    proc 'pulldown_node'    ---------------------------

# get highest pulldown node
proc pulldown_node {nodes} {

    global verbose

    set node 0
    foreach item [lindex $nodes 1] {
        if {[string is entier $item]} {
            set node $item
            break
        }
    }

    # verbose message
    if {$verbose} {
        puts "pulldown_node: $node"
    }

    # done
    return $node
}


#   -------------------------------------------------------------------
#                       MAIN
#   -------------------------------------------------------------------

#   ------------    Command line parsing     --------------------------

package require cmdline;

# define program options
set options {
    {s.arg "4"          "reduce number of stacked transistors - default" }
    {o.arg "./"         "specify output directory - default" }
    {v                  "verbose" }
}
# define program usage
set usage "- Generate a bunch of combinatorial cells"

# error trap
try {
    array set params [cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
    # Trap the usage signal, print the massage, and exit the application.
    # Note: Others errors are not caught and passed through to higher levels!
    puts $msg
    exit -1 
}

# set argv from command lines
set option_stacked $params(s) ; # number of stacked transistors
set option_path $params(o) ; # output directory
set verbose $params(v); 

# verbose message
if {$verbose} {
    puts "option_stacked (-s): $option_stacked"
    puts "option_path (-o): $option_path"
    puts "seed library: $library"
}



#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   FIXME

#foreach cell $library {
#    puts [list_nodes [lindex $cell 1]]  ; # !!
#}

foreach cell $library {
    puts [pullup_node [list_nodes [lindex $cell 1]]]
    puts [pulldown_node [list_nodes [lindex $cell 1]]]
}
# call exporter
#foreach cell $library {
#    export $option_path [lindex $cell 0] [lindex $cell 1]
#}
